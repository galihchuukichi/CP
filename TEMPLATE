#include<bits/stdc++.h>
#pragma GCC optimize("Ofast")
namespace kewajiban {
    using namespace std;
    using ll = long long;
    using ull = unsigned long long;
    #define aku ios_base::sync_with_stdio(0);cout.tie(0);cin.tie(0); 
    #define dqll(myV,a) deque<ll>myV(a)
    #define dqll2D(myV,a,b) deque<deque<ll>> myV(a,deque<ll>(b))
    #define pll pair<ll,ll>
    #define mpll map<ll,ll>
    #define fr first
    #define sc second
    //lower_bound >= x
    //upper_bound > x
    #define fup(i,a,b,c) for(ll i=a; i<=b; i+=c)
    #define fdown(i,a,b,c) for(ll i=a; i>=b; i-=c)
    #define sp cout<<" ";
    #define pb emplace_back
    #define pf emplace_front
    #define pob pop_back
    #define pof pop_front
    #define gcd(a,b) __gcd(a,b)
    #define lcm(a,b) (a*(b/gcd(a,b)))
}
using namespace kewajiban;
template<typename T> inline void ctk(T lx){
    std::cout << lx << endl;
    return;
}

ll n,tc,t,x,y,tmp;
string s;

void solve(int dep){

}

signed main(){
    aku 
    // cin >> tc;
    tc=1;
    while(tc--){
        // cin>>n;
        solve(0);
    }
}


    				
/*

// STACK



// VECTOR && DEQUE
dqll(myV,mySize);
myV.reverse(v.begin(),v.end());

myV = {1,2,3,4,5}
myV.insert(myV.begin()+2,100);
myV = {1,2,100,3,4,5}

reverse(myV.begin(),myV.begin()+3); // asal : 1 2 3 4 5
myV = {3, 2, 1, 4, 5}

myV = {1,2,3,4,5};
myV.erase(myV.begin()+1,myV.begin()+4);
myV = {1,5}


DEQUE ga bisa “myDq(5) = {1,2,3,4,5};
Array JAUH LEBIH EFISIEN dibandingkan DEQUE dalam hal TIME COMPLEXITY & MEMORY

// FUNGSI
void fungsi(int* arr){}; // simpen alamat
myInput.clear(); // 80% NOT EFFICIENT

// ERROR
for(ll i=0; i<=cari.size()-1; i++) cout<<i<<" "; // INI RTE
for(ll i=0; i<=-1; i++) cout<<i<<” “; // INI AMAN

/* ################ SEGMENT TREE ################ 
#include <iostream>
#include <vector>
using namespace std;

// Fungsi untuk membangun pohon segmen
void buildSegmentTree(
    vector<int>& segmentTree, 
    const vector<int>& arr, 
    int node, int start, int end) {
        
    if (start == end) {
        segmentTree[node] = arr[start];
    } else {
        int mid = (start + end) / 2;
        
        //Membangun anak kiri
        buildSegmentTree(segmentTree,
        arr, 2 * node + 1, start, mid);
        
        //Membangun anak kanan
        buildSegmentTree(segmentTree,
        arr, 2 * node + 2, mid + 1, end); 
        
        // Menggabungkan informasi dari anak-anak
        segmentTree[node] = segmentTree[2 * node + 1] + segmentTree[2 * node + 2];   
    }
}

// Fungsi untuk melakukan query pada pohon segmen
int querySegmentTree(   const vector<int>& segmentTree, 
                        int node, int start, int end, int qStart, int qEnd) {
        
    if (qStart > end || qEnd < start) {
        return 0;   // Jika rentang query berada di luar rentang pohon segmen saat ini
    } else if (qStart <= start && qEnd >= end) {
        return segmentTree[node];   // Jika rentang query sepenuhnya mencakup rentang pohon segmen saat ini
    } else {
        int mid = (start + end) / 2;
        int leftSum = querySegmentTree(segmentTree, 2 * node + 1, start, mid, qStart, qEnd);     // Query pada anak kiri
        int rightSum = querySegmentTree(segmentTree, 2 * node + 2, mid + 1, end, qStart, qEnd);   // Query pada anak kanan
        return leftSum + rightSum;   // Menggabungkan hasil query anak-anak
    }
}

// Fungsi untuk memperbarui elemen dalam pohon segmen
void updateSegmentTree( vector<int>& segmentTree, 
                        int node, int start, int end, int idx, int newValue) {
    if (start == end) {
        segmentTree[node] = newValue;
    } else {
        int mid = (start + end) / 2;
        if (idx >= start && idx <= mid) {
            // Perbarui anak kiri
            updateSegmentTree(segmentTree, 2 * node + 1, start, mid, idx, newValue);    
        } else {
            // Perbarui anak kanan
            updateSegmentTree(segmentTree, 2 * node + 2, mid + 1, end, idx, newValue);  
        }
        // Menggabungkan informasi dari anak-anak
        segmentTree[node] = segmentTree[2 * node + 1] + segmentTree[2 * node + 2];   
    }
}

int main() {
    vector<int> arr = {1, 3, 5, 7, 9, 11};
    int n = arr.size();

    // Menghitung ukuran pohon segmen
    int segmentTreeSize = 2 * n - 1;
    vector<int> segmentTree(segmentTreeSize, 0);

    // Membangun pohon segmen
    buildSegmentTree(segmentTree, arr, 0, 0, n - 1);

    // Contoh penggunaan fungsi querySegmentTree
    int queryStart = 1;
    int queryEnd = 4;
    int sumInRange = querySegmentTree(segmentTree, 0, 0, n - 1, queryStart, queryEnd);
    cout << "Jumlah dalam rentang [" << queryStart << ", " << queryEnd << "] adalah " << sumInRange << endl;

    // Contoh penggunaan fungsi updateSegmentTree
    int updateIndex = 2;
    int newValue = 6;
    arr[updateIndex] = newValue;
    updateSegmentTree(segmentTree, 0, 0, n - 1, updateIndex, newValue);
    cout << "Elemen pada indeks " << updateIndex << " telah diperbarui menjadi " << newValue << endl;

    // Menghitung ulang jumlah dalam rentang setelah pembaruan
    sumInRange = querySegmentTree(segmentTree, 0, 0, n - 1, queryStart, queryEnd);
    cout << "Jumlah dalam rentang [" << queryStart << ", " << queryEnd << "] setelah pembaruan adalah " << sumInRange << endl;

    return 0;
}

// ################# SEGMENT TREE END ################# 
*/





/*
swap(a,b); tuker
LLONG_MAX | INT_MAX
auto it = lower_bound(v.begin(),v.end(),3)
it == v.end() GA NEMU
index = it-v.begin()+1 | value = *it

vector<vector<int>> adj(5);
Deque;
Can access using [], deq.front(), deq.back(), deq.pop_back(), deq.pop_front();

adj[4].pb(1);

  // Resize the vector to have 3 rows and 4 columns
    vec2d.resize(3, std::vector<int>(4));

lower_bound >= x
upper_bound > x

vector<vll> DP(505,vll(505,-1));
//creates 2D vector with 505 x 505 size and initialized all element with -1

vi A = {1,2,3,4,5};
A.erase(A.begin()+2);
A = {1,2,4,5};

tuple<int, string, bool> myTuple(42, "hello", true);
deque<tuple<ll,bool,string>> myDt;
myDt.pb(23,1,”halo”);
    cout << get<0>(myTuple) << endl;   // output: 42
    cout << get<1>(myTuple) << endl;   // output: hello
    cout << get<2>(myTuple) << endl;   // output: 1 (true)

void printArray(int arr[], int size){} //without using ‘&’ langsung disimpen address nya jadinya langsung ganti

Memset ga bisa dipake di vector
Pake myVec.clear(); // ini better

// void myF(vll& arr){} // harus pake & supaya nilainya juga berubah

INPUT



    */









